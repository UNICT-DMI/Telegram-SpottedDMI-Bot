"""Common info needed in both command and callback handlers"""
from telegram import Bot, Update, Message, CallbackQuery, ReplyMarkup, Chat, InlineKeyboardMarkup
from telegram.ext import CallbackContext
from telegram.error import BadRequest
from modules.debug.log_manager import logger
from modules.data import Config, PendingPost, PublishedPost, User
from modules.utils.keyboard_util import get_approve_kb, get_vote_kb


class EventInfo():  # pylint: disable=too-many-public-methods
    """Class that contains all the relevant information related to an event"""

    def __init__(self,
                 bot: Bot,
                 ctx: CallbackContext,
                 update: Update = None,
                 message: Message = None,
                 query: CallbackQuery = None):
        self.__bot = bot
        self.__ctx = ctx
        self.__update = update
        self.__message = message
        self.__query = query

    @property
    def bot(self) -> Bot:
        """Instance of the telegram bot"""
        return self.__bot

    @property
    def context(self) -> CallbackContext:
        """Context generated by some event"""
        return self.__ctx

    @property
    def update(self) -> Update:
        """Update generated by some event"""
        return self.__update

    @property
    def message(self) -> Message:
        """Message that caused the update"""
        return self.__message

    @property
    def bot_data(self) -> dict:
        """Data related to the bot. Is not persistent between restarts"""
        return self.__ctx.bot_data

    @property
    def user_data(self) -> dict:
        """Data related to the user. Is not persistent between restarts"""
        return self.__ctx.user_data

    @property
    def chat_id(self) -> int:
        """Id of the chat where the event happened"""
        if self.__message is None:
            return None
        return self.__message.chat_id

    @property
    def chat_type(self) -> str:
        """Type of the chat where the event happened"""
        if self.__message is None:
            return None
        return self.__message.chat.type

    @property
    def is_private_chat(self) -> bool:
        """Whether the chat is private or not"""

        if self.chat_type is None:
            return None
        return self.chat_type == Chat.PRIVATE

    @property
    def text(self) -> str:
        """Text of the message that caused the update"""
        if self.__message is None:
            return None
        return self.__message.text

    @property
    def message_id(self) -> int:
        """Id of the message that caused the update"""
        if self.__message is None:
            return None
        return self.__message.message_id

    @property
    def is_valid_message_type(self) -> bool:
        """Whether or not the type of the message is supported"""
        if self.__message is None:
            return None
        return self.__message.text or self.__message.photo or self.__message.voice or self.__message.audio\
        or self.__message.video or self.__message.animation or self.__message.sticker or self.__message.poll

    @property
    def reply_markup(self) -> ReplyMarkup:
        """Reply_markup of the message that caused the update"""
        if self.__message is None:
            return None
        return self.__message.reply_markup

    @property
    def user_id(self) -> int:
        """Id of the user that caused the update"""
        if self.__query is not None:
            return self.__query.from_user.id
        if self.__message is not None:
            return self.__message.from_user.id
        return None

    @property
    def user_username(self) -> int:
        """Username of the user that caused the update"""
        if self.__query is not None:
            return self.__query.from_user.username
        if self.__message is not None:
            return self.__message.from_user.username
        return None

    @property
    def user_name(self) -> str:
        """Name of the user that caused the update"""
        if self.__query is not None:
            return self.__query.from_user.name
        if self.__message is not None:
            return self.__message.from_user.name
        return None

    @property
    def inline_keyboard(self) -> InlineKeyboardMarkup:
        """InlineKeyboard attached to the message"""
        if self.__message is None:
            return None
        return self.__message.reply_markup

    @property
    def query_id(self) -> int:
        """Id of the query that caused the update"""
        if self.__query is None:
            return None
        return self.__query.id

    @property
    def query_data(self) -> str:
        """Data associated with the query that caused the update"""
        if self.__query is None:
            return None
        return self.__query.data

    @property
    def forward_from_id(self) -> int:
        """Id of the original message that has been forwarded"""
        if self.__message is None:
            return None
        return self.__message.forward_from_message_id

    @property
    def forward_from_chat_id(self) -> int:
        """Id of the original chat the message has been forwarded from"""
        if self.__message is None or self.__message.forward_from_chat is None:
            return None
        return self.__message.forward_from_chat.id

    @classmethod
    def from_message(cls, update: Update, ctx: CallbackContext) -> 'EventInfo':
        """Instance of EventInfo created by a message update

        Args:
            update: update event
            context: context passed by the handler

        Returns:
            instance of the class
        """
        message = update.message if update.message is not None else update.edited_message
        return cls(bot=ctx.bot, ctx=ctx, update=update, message=message)

    @classmethod
    def from_callback(cls, update: Update, ctx: CallbackContext) -> 'EventInfo':
        """Instance of EventInfo created by a callback update

        Args:
            update: update event
            context: context passed by the handler

        Returns:
            instance of the class
        """
        return cls(bot=ctx.bot, ctx=ctx, update=update, message=update.callback_query.message, query=update.callback_query)

    @classmethod
    def from_job(cls, ctx: CallbackContext) -> 'EventInfo':
        """Instance of EventInfo created by a job update

        Args:
            context: context passed by the handler

        Returns:
            instance of the class
        """
        return cls(bot=ctx.bot, ctx=ctx)

    def answer_callback_query(self, text: str = None):
        """Calls the answer_callback_query method of the bot class, while also handling the exception

        Args:
            text: Text to show to the user
        """
        try:
            self.__bot.answer_callback_query(callback_query_id=self.query_id, text=text)
        except BadRequest as ex:
            logger.warning("On answer_callback_query: %s", ex)

    def edit_inline_keyboard(self, chat_id: int = None, message_id: int = None, new_keyboard: InlineKeyboardMarkup = None):
        """Generic wrapper used to edit the inline keyboard of a message with the telegram bot,
        while also handling the exception

        Args:
            chat_id: id of the chat the message to edit belongs to or the current chat if None
            message_id: id of the message to edit. It is the current message if left None
            new_keyboard: new inline keyboard to assign to the message
        """
        chat_id = chat_id if chat_id is not None else self.chat_id
        message_id = message_id if message_id is not None else self.message_id
        try:
            self.__bot.edit_message_reply_markup(chat_id=chat_id, message_id=message_id, reply_markup=new_keyboard)
        except BadRequest as ex:
            logger.error("EventInfo.edit_inline_keyboard: %s", ex)

    def send_post_to_admins(self) -> bool:
        """Sends the post to the admin group, so it can be approved

        Returns:
            whether or not the operation was successful
        """
        message = self.__message.reply_to_message
        group_id = Config.meme_get('group_id')
        poll = message.poll  # if the message is a poll, get its reference

        try:
            if poll:  # makes sure the poll is anonym
                g_message_id = self.__bot.send_poll(chat_id=group_id,
                                                    question=poll.question,
                                                    options=[option.text for option in poll.options],
                                                    type=poll.type,
                                                    allows_multiple_answers=poll.allows_multiple_answers,
                                                    correct_option_id=poll.correct_option_id,
                                                    reply_markup=get_approve_kb()).message_id
            elif message.text and message.entities:  # maintains the previews, if present
                show_preview = self.user_data.get('show_preview', True)
                g_message_id = self.__bot.send_message(chat_id=group_id,
                                                       text=message.text,
                                                       reply_markup=get_approve_kb(),
                                                       entities=message.entities,
                                                       disable_web_page_preview=not show_preview).message_id
            else:
                g_message_id = self.__bot.copy_message(chat_id=group_id,
                                                       from_chat_id=message.chat_id,
                                                       message_id=message.message_id,
                                                       reply_markup=get_approve_kb()).message_id
        except BadRequest as ex:
            logger.error("Sending the post on send_post_to: %s", ex)
            return False

        PendingPost.create(user_message=message, group_id=group_id, g_message_id=g_message_id)

        return True

    def send_post_to_channel(self, user_id: int):
        """Sends the post to  the channel, so it can be enjoyed by the users (and voted, if comments are disabled)"""

        message = self.__message
        channel_id = Config.meme_get('channel_id')
        poll = message.poll  # if the message is a poll, get its reference

        reply_markup = None
        if not Config.meme_get('comments'):  # ... append the voting Inline Keyboard, if comments are not to be supported
            reply_markup = get_vote_kb()
        if poll:  # makes sure the poll is anonym
            c_message_id = self.__bot.send_poll(chat_id=channel_id,
                                                question=poll.question,
                                                options=[option.text for option in poll.options],
                                                type=poll.type,
                                                allows_multiple_answers=poll.allows_multiple_answers,
                                                correct_option_id=poll.correct_option_id,
                                                reply_markup=reply_markup).message_id
        else:
            c_message_id = self.__bot.copy_message(chat_id=channel_id,
                                                   from_chat_id=message.chat_id,
                                                   message_id=message.message_id,
                                                   reply_markup=reply_markup).message_id

        if not Config.meme_get('comments'):  # if the user can vote directly on the post
            PublishedPost.create(c_message_id=c_message_id, channel_id=channel_id)
        else:  # ... else, if comments are enabled, save the user_id, so the user can be credited
            self.bot_data[f"{channel_id},{c_message_id}"] = user_id

    def send_post_to_channel_group(self):
        """Sends the post to the group associated to the channel, so that users can vote the post (if comments are enabled)"""

        message = self.__message
        channel_group_id = Config.meme_get('channel_group_id')
        user_id = self.bot_data.pop(f"{self.forward_from_chat_id},{self.forward_from_id}", -1)

        sign = User(user_id).get_user_sign(bot=self.__bot)
        post_message_id = self.__bot.send_message(chat_id=channel_group_id,
                                                  text=f"by: {sign}",
                                                  reply_markup=get_vote_kb(),
                                                  reply_to_message_id=message.message_id).message_id

        PublishedPost.create(channel_id=channel_group_id, c_message_id=post_message_id)
